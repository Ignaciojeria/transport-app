package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"

	//	"transport-app/app/adapter/in/graphql/graph/mapper"

	"transport-app/app/adapter/in/graphql/graph/mapper"
	"transport-app/app/adapter/in/graphql/graph/model"
	"transport-app/app/domain"
)

// Orders is the resolver for the orders field.
// Orders es el resolver para el campo orders.
func (r *queryResolver) Orders(
	ctx context.Context,
	filter *model.OrderFilterInput,
	first *int,
	after *string,
	last *int,
	before *string,
) (*model.OrderConnection, error) {
	fmt.Println("executing Orders resolver with filter:", filter)
	requestedFields := CollectSelectedPaths(ctx)
	fmt.Println("Requested fields:", requestedFields)

	// Definir límites
	limit := 10 // valor por defecto
	if first != nil {
		limit = *first
		if limit > 100 {
			limit = 100 // límite máximo
		}
	}

	// Procesar cursor si existe
	var afterID string
	if after != nil {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		afterID = string(decoded)
	}

	// En una implementación real, obtendrías datos de tu repositorio
	// ordersData, err := r.OrderRepository.GetOrders(filter, afterID, limit+1)

	// Por ahora, simulamos datos para demostración
	// Aquí simulamos obtener limit+1 registros para verificar hasNextPage
	ordersData := []*model.Order{
		{
			ReferenceID: "REF123",
			Packages: []*model.Package{
				{
					Lpn: stringPtr("label:1234567890"),
				},
			},
		},
	}

	// Verificar si hay más páginas
	hasNextPage := len(ordersData) > limit
	if hasNextPage {
		ordersData = ordersData[:limit] // quitar el elemento extra
	}

	// Construir edges
	edges := make([]*model.OrderEdge, len(ordersData))
	for i, order := range ordersData {
		// En una aplicación real, usarías un ID único como orderID
		orderID := strconv.Itoa(i + 1)
		if afterID != "" {
			// Si hay un cursor, incrementar el índice basado en él
			afterIDInt, _ := strconv.Atoi(afterID)
			orderID = strconv.Itoa(afterIDInt + i + 1)
		}

		cursor := base64.StdEncoding.EncodeToString([]byte(orderID))
		edges[i] = &model.OrderEdge{
			Cursor: cursor,
			Node:   order,
		}
	}

	// Construir pageInfo con todos los campos requeridos
	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = edges[0].Cursor
		endCursor = edges[len(edges)-1].Cursor
	}

	// Determinar hasPreviousPage
	// En una implementación real, esto dependería de tu lógica de paginación
	hasPreviousPage := false
	if after != nil {
		hasPreviousPage = true // Si hay un cursor 'after', entonces hay páginas previas
	}

	pageInfo := &model.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     &startCursor, // Ahora usamos la variable
		EndCursor:       endCursor,
	}

	r.SearchOrders(ctx, mapper.MapOrderFilterWithPagination(filter, domain.Pagination{
		First:  first,
		Last:   last,
		After:  after,
		Before: before,
	}, requestedFields))

	return &model.OrderConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

// Helper para crear punteros a string
func stringPtr(s string) *string {
	return &s
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) Todos(ctx context.Context) ([]*model.Order, error) {
	// Simulamos una respuesta con datos falsos (mock)
	return []*model.Order{
		{
			ID:          "1",
			ReferenceID: "REF123",
		},
		{
			ID:          "2",
			ReferenceID: "REF456",
		},
	}, nil
}
*/

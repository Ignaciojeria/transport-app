package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.72

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"

	//	"transport-app/app/adapter/in/graphql/graph/mapper"

	"transport-app/app/adapter/in/graphql/graph/mapper"
	"transport-app/app/adapter/in/graphql/graph/model"
	"transport-app/app/domain"
)

// Orders is the resolver for the orders field.
// Orders es el resolver para el campo orders.
func (r *queryResolver) DeliveryUnitsReports(
	ctx context.Context,
	filter *model.DeliveryUnitsReportFilterInput,
	first *int,
	after *string,
	last *int,
	before *string,
) (*model.DeliveryUnitsReportConnection, error) {
	fmt.Println("executing Orders resolver with filter:", filter)
	requestedFields := CollectSelectedPaths(ctx)
	fmt.Println("Requested fields:", requestedFields)

	// Definir límites
	const maxLimit = 100 // límite máximo razonable para paginación

	// Procesar first/last
	if first != nil {
		if *first > maxLimit {
			return nil, fmt.Errorf("requested limit %d exceeds maximum allowed limit of %d", *first, maxLimit)
		}
	} else if last != nil {
		if *last > maxLimit {
			return nil, fmt.Errorf("requested limit %d exceeds maximum allowed limit of %d", *last, maxLimit)
		}
	}

	// Procesar cursores si existen
	var afterID, beforeID *string

	if after != nil && *after != "" {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, fmt.Errorf("invalid 'after' cursor: %v", err)
		}
		// Convertir el string decodificado a int64
		id, err := strconv.ParseInt(string(decoded), 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid 'after' cursor format: %v", err)
		}
		s := strconv.FormatInt(id, 10)
		afterID = &s
	}

	if before != nil && *before != "" {
		decoded, err := base64.StdEncoding.DecodeString(*before)
		if err != nil {
			return nil, fmt.Errorf("invalid 'before' cursor: %v", err)
		}
		// Convertir el string decodificado a int64
		id, err := strconv.ParseInt(string(decoded), 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid 'before' cursor format: %v", err)
		}
		s := strconv.FormatInt(id, 10)
		beforeID = &s
	}

	pagination := domain.Pagination{
		First:  first,
		After:  afterID,
		Last:   last,
		Before: beforeID,
	}

	if err := pagination.IsValid(); err != nil {
		return nil, err
	}

	requestedFieldsAsMap := ConvertSelectedPathsToMap(ctx)
	fmt.Printf("requestedFieldsAsMap type: %T\n", requestedFieldsAsMap)

	// Construir el filtro
	deliveryUnitsFilter := domain.DeliveryUnitsFilter{
		RequestedFields: requestedFieldsAsMap,
		Pagination:      pagination,
	}

	// Agregar filtros si existen
	if filter != nil {
		if filter.OnlyLatestStatus != nil {
			deliveryUnitsFilter.OnlyLatestStatus = *filter.OnlyLatestStatus
		}

		if len(filter.ReferenceIds) > 0 {
			// Convertir []*string a []string
			referenceIds := make([]string, len(filter.ReferenceIds))
			for i, ref := range filter.ReferenceIds {
				if ref != nil {
					referenceIds[i] = *ref
				}
			}
			deliveryUnitsFilter.ReferenceIds = referenceIds
		}

		if len(filter.References) > 0 {
			// Convertir los references del modelo GraphQL al dominio
			references := make([]domain.ReferenceFilter, len(filter.References))
			for i, ref := range filter.References {
				if ref != nil {
					references[i] = domain.ReferenceFilter{
						Type:  ref.Type,
						Value: ref.Value,
					}
				}
			}
			deliveryUnitsFilter.References = references
		}

		if len(filter.Labels) > 0 {
			labels := make([]domain.LabelFilter, len(filter.Labels))
			for i, label := range filter.Labels {
				if label != nil {
					labels[i] = domain.LabelFilter{
						Type:  label.Type,
						Value: label.Value,
					}
				}
			}
			deliveryUnitsFilter.Labels = labels
		}

		if len(filter.Lpns) > 0 {
			// Convertir []*string a []string
			lpns := make([]string, len(filter.Lpns))
			for i, lpn := range filter.Lpns {
				if lpn != nil {
					lpns[i] = *lpn
				}
			}
			deliveryUnitsFilter.Lpns = lpns
		}

		if len(filter.OriginNodeReferences) > 0 {
			// Convertir []*string a []string
			originNodeReferences := make([]string, len(filter.OriginNodeReferences))
			for i, ref := range filter.OriginNodeReferences {
				if ref != nil {
					originNodeReferences[i] = *ref
				}
			}
			deliveryUnitsFilter.OriginNodeReferences = originNodeReferences
		}

		if filter.CoordinatesConfidenceLevel != nil {
			deliveryUnitsFilter.CoordinatesConfidenceLevel = &domain.CoordinatesConfidenceLevelFilter{
				Min: filter.CoordinatesConfidenceLevel.Min,
				Max: filter.CoordinatesConfidenceLevel.Max,
			}
		}

		if filter.PromisedDateRangeDateFilter != nil {
			deliveryUnitsFilter.PromisedDateRange = &domain.PromisedDateRangeFilter{
				StartDate: filter.PromisedDateRangeDateFilter.StartDate,
				EndDate:   filter.PromisedDateRangeDateFilter.EndDate,
			}
		}

		if len(filter.SizeCategories) > 0 {
			// Convertir []*string a []string
			sizeCategories := make([]string, len(filter.SizeCategories))
			for i, size := range filter.SizeCategories {
				if size != nil {
					sizeCategories[i] = *size
				}
			}
			deliveryUnitsFilter.SizeCategories = sizeCategories
		}
	}

	results, hasMore, err := r.findDeliveryUnitsProjectionResult(ctx, deliveryUnitsFilter)
	if err != nil {
		return nil, err
	}

	// Mapear los resultados
	deliveryUnits := mapper.MapDeliveryUnits(ctx, results)

	// Construir edges
	edges := make([]*model.DeliveryUnitsReportEdge, len(deliveryUnits))
	for i, order := range deliveryUnits {
		// Codificar el ID numérico en base64
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.FormatInt(results[i].ID, 10)))
		edges[i] = &model.DeliveryUnitsReportEdge{
			Cursor: cursor,
			Node:   order,
		}
	}

	// Construir pageInfo con todos los campos requeridos
	var startCursor, endCursor string
	if len(edges) > 0 {
		startCursor = edges[0].Cursor
		endCursor = edges[len(edges)-1].Cursor
	}

	// Determinar hasPreviousPage y hasNextPage
	hasPreviousPage := before != nil
	var hasNextPage bool
	if last != nil {
		// En paginación hacia atrás, hasNextPage es true si hay más resultados
		hasNextPage = hasMore
		hasPreviousPage = hasMore
	} else {
		// En paginación hacia adelante, hasNextPage es true si hay más resultados
		hasNextPage = hasMore
	}

	pageInfo := &model.PageInfo{
		HasNextPage:     hasNextPage,
		HasPreviousPage: hasPreviousPage,
		StartCursor:     &startCursor,
		EndCursor:       endCursor,
	}

	return &model.DeliveryUnitsReportConnection{
		Edges:    edges,
		PageInfo: pageInfo,
	}, nil
}

func ptrString(v string) *string    { return &v }
func ptrInt(v int) *int             { return &v }
func ptrFloat64(v float64) *float64 { return &v }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *queryResolver) Todos(ctx context.Context) ([]*model.Order, error) {
	// Simulamos una respuesta con datos falsos (mock)
	return []*model.Order{
		{
			ID:          "1",
			ReferenceID: "REF123",
		},
		{
			ID:          "2",
			ReferenceID: "REF456",
		},
	}, nil
}
*/
